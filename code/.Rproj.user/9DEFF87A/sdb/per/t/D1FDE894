{
    "collab_server" : "",
    "contents" : "---\ntitle: \"SalesAnalysis\"\nauthor: \"Hardeep Arora\"\ndate: \"09/12/2017\"\noutput: pdf_document\nurlcolor: blue\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(data.table)\nlibrary(corrplot)\nlibrary(xgboost)\nlibrary(caret)\nlibrary(DMwR)\nlibrary(pROC)\nlibrary(ggplot2)\nset.seed(2017)\n```\n\n## Datasets\n\n### How reliable is this data?\n\nThere are definitely some shortcomings with this dataset that would make it unreliable\n\n#### Firstly\nThis dataset has sales and inventory data for a business and it's specifically mentioned that \n\n\"It is important to note that we have MANY products in our inventory, and very few of them tend to sell (only about 10% sell each year) and many of the products only have a single sale in the course of a year.\"\n\nBut the historical data provided for sales is just for last 6 months, this means we would not have a complete picture of the sales cycle. So this make the dataset not so reliable to make a true prediction on sales.\n\nAlso since only 10% of products sell, so there is also a class imbalance issue, as there is very less sale data and we would need to take care of it using downsampling or upsampling techniques.\n\n#### Secondly\nThere is no clear indication on meaning of certain fields like\n\na. StrengthFactor - This limits the understanding and explainability of model that uses this feature.  \n\nb. PriceReg, LowUserPrice and LowNetPrice - There is no clear distinction between the three fields and hence it leaves lot of scope of assumptions which might not be true.   \n\n#### Thirdly\nThere are differences in value between SKU's common across historic and inventory data\n\na. The LowUserPrice differs a lot between historic and active records.\n\nb. ItemCount also varies without any obvious logic in a lot of cases.\n\n#### Fourthly\nThis dataset has very small subset of features, which would limit the depth of analysis that can be carried out.\n\n### How did you make an assessment?\n\nI made this assessment based on the given information and eye balling the data.\n\n### How does the data quality limit or constrain your ideas for analysis?\n\nThe data quality limits the accuracy and completness of the analysis that would be carried out on this dataset and we might observe that the model does not generalize well on the unseen data.\n\n\n### What other datasets could be brought in to enrich these questions?\n\nThere are some key other datasets that can be brought to help analyze the below questions\n\na. First we need to capture one full year of historic sales data\n\nb. Second data set containing the product features or BOM per product, would be a useful addition. It would help in conducting many more kind of analysis like price determination etc.\n\nc. Third data set containing some more information about the customers would be helpful from point of view of retailer to determine the product and price mix.\n\nd. Fourth any information on time/date of sale would be useful to carry out temporal analysis and determine seasonality in sales.\n\ne. Fifth any kind of dataset on returned/defective products.\n\n\n## Stakeholders\n\n### What interesting questions could you answer with this data?\nWe can ask some interesting questions based on this small dataset, however we would need more datasets to answer all the questions appropriately.\n\n### If you are a retailer?\n\na. What products are selling?   \n   This is also the primary question asked along with this dataset.\n   \nb. How much quantity would be sold per sale?   \n   This is useful to get an idea about inventory to maintain at retailer end.\n  \nc. What price should I charge for each product?    \n   We need some more datasets to do this analysis like product and customer features.\n\n### If you are a consumer?\n\na. What should I pay for an item?   \n   We would need more features of the product along with its BOM if possible.\n   \nb. Is this the right retailer to shop on in terms of product mix and price?   \n   We would need more features of the product along with its BOM if possible.\n\n\n### If you are a wholesaler?\n\na. Prediction of the inventory required by this retailer by product?\n\nb. What kind of sales happen at this retailer and what should be the frequency of refills?\n\nc. Prediction of items that would be returned by this retailer?\n\n\n## Analysis\n\n### What is something interesting or useful to answer? \nIn the present shape and form this dataset is most suitable to answer the retailers questions. I would try to answer what products will sell and in how much quantity. I would be leaving the price for sale, because I feel we don't have enough features to answer this question adequately.\n\nI plan to train a model on the historic data and use it to predict the values on inventory data. Given the amount of data, I feel it should be possible to make these predictions reasonably accurately.\n\n#### Exploration\nLet's explore the dataset a bit,\n\n```{r}\n\n# Read the data\ndf <- fread(\"../data/SalesKaggle3.csv\")\n\n# Separate it into Sales and Inventory data\nhistoricSales <- df[df$File_Type==\"Historical\",]\nactiveInv <- df[df$File_Type==\"Active\",]\n\ndim(historicSales)\n\ndim(activeInv)\n\ncolnames(historicSales)\n\n```\n\nSince we are going to work on sales prediction, let's first look at the distribution of soldflag.\n\n```{r}\nftable(historicSales$SoldFlag)\n```\n\n'0' means no-sales and '1' means sales and we can clearly conclude that this dataset is imbalanced.\n\nGenerally sales are correlated to the price of the product, so let us first plot the distribution of price between sale and no-sale cases. \n\n```{r, warning=FALSE, echo=FALSE}\n\nggplot(historicSales, aes(x =  PriceReg, fill = factor(SoldFlag))) +\n  geom_density(alpha = 0.5) + xlim(c(0,1000)) +xlab(\"Price\") +\n  ylab(\"density\") + ggtitle(\"Price density\") + xlim(c(0,450))\n\n```\n\n\n\n```{r, warning=FALSE, echo=FALSE}\nggplot(historicSales, aes(x = factor(SoldFlag), y = PriceReg, \n                       colour = factor(SoldFlag))) + geom_boxplot() +\n   xlab(\"Sales Flag\") + ylab(\"Price Reg\")+ ylim(0,400) + \n  ggtitle(\"Price Reg Boxplot\")\n```\nThe boxplots above shows the median price for both sale and no-sale cases and there are quite a number of outliers as well.\n\n```{r pre-process1, echo=FALSE}\n# Convert MarketingType to numeric\nhistoricSales$MarketingType <- ifelse(historicSales$MarketingType == \"D\",1,2)\n```\n\n#### Correlation plot\n\nLet's explore the correlation between the features. \n\n```{r corrplot}\ncorrplot(cor(scale(historicSales[,!c(\"File_Type\")])), method=\"circle\")\n```\n\nAbove plot shows none of the features are highly correlated to SoldFlag or SoldCount. \n\na. **SoldFlag** - **ItemCount**, **MarketingType**, **Order**, **StrengthFactor** seem to have some small positive/negative correlation. Since MarketingType and Order and highly correlated among themselves, we can drop one of them from prediction. Ofcourse we can't use **SoldCount** as a predictor since it is not available in the inventory data.\n\nb. **SoldCount** - **ItemCount**, **MarketingType**, **Order**, **StrengthFactor** seem to have some small positive/negative correlation. As stated above we would drop Order from the prediction. We can use **SaleFlag** to predict SoldCount for items that are sold, but I have decided not to do so because this would force the algo to make SaleCount close to zero for non-sale cases. In real life case if a sale happens on non-sale case, then we would have wrong indication of the how much sale would happen. Since we don't expect the sale to happen we might not stock enough inventory and end up having lost/less sale due to no-stock.\n\n\nSince ItemCount is the main feature in both cases let's explore it a bit more\n\n```{r, warning=FALSE, echo=FALSE}\nggplot(historicSales, aes(x = factor(SoldFlag), y = ItemCount, \n                       colour = factor(SoldFlag))) + geom_boxplot() +\n   xlab(\"Sales Flag\") + ylab(\"Item Count\")+ ylim(0,400) + \n  ggtitle(\"Item Count Boxplot\")\n```\n\nFrom the above boxplot we see the median ItemCount around 50 for sales and also observe some outliers above 150. We can experiment to see the impact of dropping them on our prediction later.\n\n\n#### Data Pre-Processing\nNow we would do some pre-processing of data, as listed below\n\na. Removing File_Type, Order, New_Release_Flag and SKU_numbers as they are not very useful or highly correlated to other features that we are keeping.\n\nb. Saving the SaleFlag and SaleCount as they would be target of predictions.\n\nc. Also since the dataset is imbalanced with 10% of sale cases only, would try to oversample it to make it more balanced. Here we are using [SMOTE](http://amunategui.github.io/smote/). I have tried without upsampling and the sensitivity in that case is less than 20%. \n\n```{r pre-process, cache=TRUE}\n# Columns to Exclude\ncols = c(\"File_Type\",\"Order\",\"SKU_number\",\"New_Release_Flag\")\nhistoricSales <- historicSales[,!cols,with=FALSE]\n\n# Balance the classes using oversampling\nhistoricSales$SoldFlag <- as.factor(historicSales$SoldFlag)\nhistoricSales1 <- SMOTE(SoldFlag ~ . , \n                       data= historicSales, perc.over = 100, perc.under = 200)\n\ntarget.sales <- as.data.table(as.numeric(as.character(historicSales1$SoldFlag)))\ntarget.sales.count <- as.data.table(historicSales1$SoldCount)\n\nhistoricSales <- historicSales1\n\nftable(historicSales$SoldFlag)\n\nhistoricSales <- historicSales[,!c(\"SoldFlag\",\"SoldCount\"),with=FALSE]\n```\n\nThe classes are balanced now. \n\n#### Data Partitioning\n\nNow let's divide the data into test and train samples in ratio 20-80.\n\n```{r split, cache=TRUE}\n# Divide the data into train and test set (0.8,0.2)\ntestSize <- 0.2\nindexes = sample(1:nrow(historicSales), size=testSize*nrow(historicSales))\n\n# Split data\ntest <- historicSales[indexes,]\ntrain <- historicSales[-indexes,]\n\nlbl_train.sales <- target.sales[-indexes,]\nlbl_test.sales <- target.sales[indexes,]\n\nlbl_train.sales.count <- target.sales.count[-indexes,]\nlbl_test.sales.count <- target.sales.count[indexes,]\n```\n\n#### SaleFlag Prediction\n\nNow let's train a gradient boosted tree (xgboost) to predict the SoldFlag on this data. It would be binary logistic regression to predict the probability of sale between 0 and 1.\n\n```{r train_soldFlag, results=\"hide\", cache=TRUE}\n# Train the model for SaleFlag Prediction\nnew_tr <- model.matrix(~.,data = train) \nnew_ts <- model.matrix(~.,data = test)\n\nlbl_train <- lbl_train.sales$V1\nlbl_test <- lbl_test.sales$V1\n\ndtrain <- xgb.DMatrix(data = new_tr,label = lbl_train) \ndtest <- xgb.DMatrix(data = new_ts,label=lbl_test)\n\nparams <- list(booster = \"gbtree\", \n               objective = \"binary:logistic\", \n               eta=0.01, \n               gamma=0, \n               max_depth=7, \n               min_child_weight=1, \n               subsample=1, \n               colsample_bytree=1)\n\nset.seed(101)\nxgb.sales <- xgb.train (params = params, \n                   data = dtrain, \n                   nrounds = 1510, \n                   watchlist = list(train=dtrain,val=dtest), \n                   print_every_n = 10, \n                   early_stopping_rounds = 10, \n                   maximize = T , \n                   eval_metric = \"auc\")\n```\n\n### What evidence or rationale supports your findings?\n\nNow let's print the results\n\n#### Feature importance\n\n```{r pred_soldFlag_1}\nmat <- xgb.importance (feature_names = colnames(new_tr),model = xgb.sales)\nxgb.plot.importance (importance_matrix = mat) \n```\n\nAs anticipated from the correlation plots earlier, indeed the feature importance from xgboost show the same results.\n\n#### Prediction distribution\n\n```{r pre_soldFlag_2}\nxgbpred <- predict (xgb.sales,dtest)\ntest$pred <- xgbpred\n\nggplot(test, aes(x=pred, colour =factor(lbl_test.sales$V1), \n                 fill = factor(lbl_test.sales$V1), alpha = 0.5)) + \n  geom_density()\n```\n\nThe distribution of predictions are nicely separated at probability of 0.5\n\n#### ROC curve\n\n```{r pre_soldFlag_3}\nplot(pROC::roc(response = lbl_test.sales$V1,\n               predictor = xgbpred,\n               levels=c(0, 1)),lwd=1.5)\n\nxgbpred <- ifelse (xgbpred > 0.5,1,0)\n\nconfusionMatrix (xgbpred, lbl_test)\n```\n\nThe AUC is approx 77% and True Positve (Sensitivity) and True Negative (Specificity) is also above 75%. \n\nThis looks to be good results for time being.\n\n#### SaleCount Prediction\n\nNow let's train the SaleCount predictor using gradient boosted trees (xgboost). In this case we would be doing a linear regression to predict the SoldCount.\n\n```{r pred_saleCount, results=\"hide\", cache=TRUE}\nnew_tr <- model.matrix(~.,data = train) \nnew_ts <- model.matrix(~.,data = test)\n\nlbl_train <- lbl_train.sales.count$V1\nlbl_test <- lbl_test.sales.count$V1\n\ndtrain <- xgb.DMatrix(data = new_tr,label = lbl_train) \ndtest <- xgb.DMatrix(data = new_ts,label=lbl_test)\n\nparams <- list(booster = \"gbtree\", \n               objective = \"reg:linear\", \n               eta=0.1, \n               gamma=0, \n               max_depth=7, \n               min_child_weight=1, \n               subsample=1, \n               colsample_bytree=1)\n\nset.seed(101)\nxgb.sales.count <- xgb.train (params = params, \n                        data = dtrain, \n                        nrounds = 1510, \n                        watchlist = list(train=dtrain,val=dtest), \n                        print_every_n = 10, \n                        #early_stopping_rounds = 10, \n                        maximize = T , \n                        eval_metric = \"rmse\")\n```\n\nThe validation RMSE error is around 1.4 which is not that good and the algo tends to overfit on the training data as the training loss keeps going down.\n\n```{r pred_saleCountRes_1}\nmat <- xgb.importance (feature_names = colnames(new_tr),model = xgb.sales.count)\nxgb.plot.importance (importance_matrix = mat) \n```\n\nFeature importance shows ReleaseYear as the top feature instead of ItemCount which is surprising as it's not that evident from the correlation analysis above.\n\nEye balling the predictions \n```{r pred_saleCountRes_2}\nxgbpred <- predict (xgb.sales.count,dtest)\n\ntest1 <- test\ntest1$SoldCount <- lbl_test\ntest1$PredSC <- ifelse(xgbpred < 0.1, 0, xgbpred)\n\nhead(test1[,c(\"SoldCount\",\"PredSC\"),with=FALSE])\n```\n\nThis would need some further fine tuning and analysis, but due to lack of time I am leaving it at this point.\n\n### Predicting on Inventory Data\n\nNow let's use the trained models to predict SaleFlag and SaleCount on the inventory data\n\n```{r invPred}\n### Predict Sale on the Inventory\ncols = c(\"File_Type\",\"Order\",\"SKU_number\",\"SoldCount\",\"SoldFlag\")\nactiveInv <- activeInv[,!cols,with=FALSE]\n\n# Convert MarketingType to numeric\nactiveInv$MarketingType <- ifelse(activeInv$MarketingType == \"D\",1,2)\n\nnew_inv <- model.matrix(~.,data = activeInv)\ndinv <- xgb.DMatrix(data = new_inv)\nxgbpredInv <- predict (xgb.sales,dinv)\nxgbpredInv <- ifelse (xgbpredInv > 0.5,1,0)\nactiveInv$SoldFlag <- xgbpredInv\nsalesCount <- predict (xgb.sales.count,dinv)\nactiveInv$SoldCount <- ifelse(salesCount < 0.1, 0, salesCount)\n\ninvSample <- df[df$File_Type==\"Active\",]\ninvSample$SoldFlag <- activeInv$SoldFlag\ninvSample$SoldCount <- activeInv$SoldCount\n\nhead(invSample[,c(\"SKU_number\",\"SoldFlag\",\"SoldCount\"),with=FALSE])\n```\n\nThis finishes the prediction part. Here we could predict the SaleFlag with 77% accuracy but the SaleCount still needs some improvement and work.\n\n\n### If a client wanted to track these insights ongoing\n\n#### How would you go about designing an operational solution?\nIn order to build an operational solution we can have 2 possible approaches based on the frequency.\n\na. **Weekly/Daily/Real-time** : In this case I would prefer to build an end-to-end data pipline with this model automated and working in an unattended manner. Having said that if the metrics of the model fall below a threshold value then we would need to retrain and redeploy the model. This part of retraining can also be automated if required.\n\nb. **Monthly/Quarterly/Yearly** : In this case we can run the model on adhoc basis manually and the data pipline can be manual as well.\n\nOn a high-level the solution would entail a data drop in form of csv file followed by some R/Python scripts for data cleaning, followed by the R/Python script for model predictions. The predictions can then be embedded in an automated pipeline or send out to people to take actions.\n\n#### How would you go about estimating time/cost/skills needed to build something?\n\nTime/Cost/Skills would be a function of what approach with take as listed above. In case of first approach, initial time/cost/skills would be higher both from data science and engineering teams. The on-going support would be less and would depend on how frequently do we need to retrain the model because of distribution shifts etc.\n\nIn case of latter approach, the initial time/cost/skills to market would be less, but it would be need periodic effort to manually churn out results.\n\n#### What are some of the top challenges you would expect?\nThe main challenges would be as follows\n\na. **Data sourcing & quality**: Ensuring that there is a data pipeline in place that can generate the required input data in a consistent/accurate manner.\n\nb. **Shifting data distribution**: There is chance that the model needs to be frequently re-trained, in case the data distribution or patterns change in production frequently. In such a case we would need to further invest time in some form of online learning infrastructure.\n\n\n## Appendix\n\nIn this analysis for modeling I have used gradient boosted tree's ( [xgboost](https://github.com/dmlc/xgboost) )\n\nOther packages used are as follows\n\na. [data.table](https://github.com/Rdatatable/data.table/wiki) - This is the new, fast mechanism to read and manipulate data in R.\n\nb. [corrplot](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) - Most popular package to plot correlation between features.\n\nc. [caret](http://caret.r-forge.r-project.org/) - I just used it for showing the confusion matrix.\n\nd. [DMwR](https://cran.r-project.org/web/packages/DMwR/DMwR.pdf) - Used it for SMOTE function for up-sampling the data.\n\ne. [pROC](https://github.com/xrobin/pROC) - Used to plot the ROC curve.\n\nf. [ggplot2](http://ggplot2.org/) - Popular plotting library in R.\n\n",
    "created" : 1512799211988.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3867116729",
    "id" : "D1FDE894",
    "lastKnownWriteTime" : 1512835660,
    "last_content_update" : 1512835660105,
    "path" : "~/Documents/DataScience/Kaggle/BRIGHTSTAR/code/SalesAnalysis.rmd",
    "project_path" : "SalesAnalysis.rmd",
    "properties" : {
        "last_setup_crc32" : "CF75DF174a6b65f",
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}